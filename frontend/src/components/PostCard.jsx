// src/components/PostCard.jsx
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { followUser, unfollowUser, fetchFollowing } from '../features/auth/authSlice';

const PostCard = ({ post }) => { // Removed toggleLike, addComment, likes, comments from props as PostCard manages them
  const dispatch = useDispatch();
  // Get current user, their following list, and authentication status from Redux auth slice
  const { user: currentUser, following: followingListFromRedux, isAuthenticated } = useSelector((state) => state.auth); 

  // Local state for likes and comments (as per current implementation in PostCard)
  const [currentLikes, setCurrentLikes] = useState(post.likes || 0);
  const [liked, setLiked] = useState(false); 
  
  // Local state for comments visibility and new comment input
  const [commentsVisible, setCommentsVisible] = useState(false); 
  const [currentComments, setCurrentComments] = useState(post.comments || []);
  const [newComment, setNewComment] = useState('');

  // Determine if the current user is following the post author
  // This relies on post.author_id being present in the post object
  const isFollowing = followingListFromRedux.some(followedUser => followedUser.id === post.author_id);
  // Check if the post is by the current user to disable follow/unfollow
  const isOwnPost = currentUser && currentUser.id === post.author_id;

  // Effect to re-fetch following list if current user changes or on initial load
  // This helps ensure the 'isFollowing' state is accurate
  useEffect(() => {
    if (currentUser?.id) {
      dispatch(fetchFollowing(currentUser.id));
    }
  }, [currentUser?.id, dispatch]);


  const handleLike = () => {
    // This currently updates local state. For persistence, this would also need a backend API call.
    setLiked(!liked);
    setCurrentLikes(prev => liked ? prev - 1 : prev + 1);
    // You would dispatch a like/unlike thunk here
    // dispatch(toggleLikePost(post.id)); 
  };

  const handleFollow = async () => {
    if (!isAuthenticated) {
      alert("Please log in to follow users."); // Replace with a proper modal/message
      return;
    }
    if (isOwnPost) {
      alert("You cannot follow yourself."); // Replace with a proper modal/message
      return;
    }
    // Ensure post.author_id is available before dispatching
    if (!post.author_id) {
        alert("Cannot follow: Author ID is missing for this post."); // Debugging alert
        console.error("PostCard: Missing post.author_id for follow action:", post);
        return;
    }

    try {
      if (isFollowing) {
        // If currently following, dispatch unfollow
        await dispatch(unfollowUser(post.author_id)).unwrap();
        console.log(`Successfully unfollowed user ${post.author_id}`);
      } else {
        // If not following, dispatch follow
        // The payload for followUser should ideally contain enough info to add to 'following' state
        await dispatch(followUser(post.author_id)).unwrap();
        console.log(`Successfully followed user ${post.author_id}`);
      }
      // After successful follow/unfollow, the authSlice's extraReducers will update 'followingListFromRedux'
      // which will automatically re-render this component with the correct 'isFollowing' state.
    } catch (error) {
      console.error("Failed to toggle follow:", error);
      alert(`Failed to toggle follow: ${error.message || 'An error occurred.'}`); // Replace with proper error display
    }
  };

  const handleCommentSubmit = (e) => {
    e.preventDefault();
    if (newComment.trim()) {
      const commentObj = {
        id: Date.now(), // This should be generated by backend
        text: newComment,
        author: currentUser?.username || 'Guest' // Use real user
      };
      setCurrentComments([...currentComments, commentObj]); // Update local state
      setNewComment('');
      // For persistence, you would dispatch a thunk to add comment to backend
      // dispatch(addCommentToPost({ postId: post.id, commentText: newComment }));
    }
  };

  return (
    <div className="post-card p-4 rounded-lg bg-[#1a2a44] shadow-md text-white">
      <h2 className="text-xl font-semibold text-[#ff5733] mb-1">
        {post.title || post.movie_title}
      </h2>

      <p className="text-gray-200 mb-2">{post.comment || post.content}</p>

      <div className="post-meta flex justify-between text-sm text-gray-400 mb-4">
        <span>Posted by <strong>@{post.author_username || post.author}</strong></span>
        {/* Use post.created_at for date display, assuming it's ISO formatted from backend */}
        <span>{post.created_at ? new Date(post.created_at).toLocaleDateString() : 'Invalid Date'}</span>
      </div>

      {/* Buttons */}
      <div className="post-actions flex gap-3 mb-4 flex-wrap">
        <button onClick={handleLike} className="post-btn">
          {liked ? 'üíî Unlike' : '‚ù§Ô∏è Like'} ({currentLikes})
        </button>

        <button 
          onClick={handleFollow} 
          className="post-btn"
          disabled={isOwnPost || !isAuthenticated} // Disable if it's own post or not authenticated
        >
          {isOwnPost ? 'Your Post' : (isFollowing ? 'Unfollow' : 'Follow')} @{post.author_username || post.author}
        </button>

        <button onClick={() => setCommentsVisible(prev => !prev)} className="post-btn">
          {commentsVisible ? 'Hide Comments' : 'Show Comments'}
        </button>
      </div>

      {/* Comments Section */}
      {commentsVisible && ( 
        <div className="comments-section mt-3">
          <h4 className="text-[#ff5733] font-medium mb-2">üí¨ Comments</h4>

          {currentComments.length === 0 ? (
            <p className="text-gray-400">No comments yet.</p>
          ) : (
            <ul className="space-y-1 mb-3">
              {currentComments.map((c, index) => ( 
                <li key={c.id || index} className="text-sm text-gray-200">
                  <strong>@{c.author}</strong>: {c.text}
                </li>
              ))}
            </ul>
          )}

          <form onSubmit={handleCommentSubmit}>
            <textarea
              value={newComment}
              onChange={(e) => setNewComment(e.target.value)}
              placeholder="Write a comment..."
              rows={2}
              className="w-full p-2 rounded bg-[#2c3e50] text-white border border-gray-600 mb-2"
            />
            <button
              type="submit"
              className="post-btn"
            >
              Add Comment
            </button>
          </form>
        </div>
      )}
    </div>
  );
};

export default PostCard;
